import streamlit as st
import os
import re
import uuid
import textwrap
import json
from bs4 import BeautifulSoup
from .utils import get_clean_locator_name, parse_robot_keywords
from .file_manager import read_robot_variables_from_content, create_new_robot_file, append_robot_content_intelligently, scan_robot_project
from .keyword_categorizer import categorize_keywords, get_category_stats, get_expansion_config, get_category_priority
from .menu_locator_manager import render_menu_locator_manager
# Import ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Checkbox ‡∏à‡∏≤‡∏Å module ‡∏ó‡∏µ‡πà‡πÅ‡∏¢‡∏Å‡πÑ‡∏ß‡πâ
from .checkbox_keywords_generator import analyze_checkbox_structure, generate_checkbox_template_and_keyword

# HTML Parser
try:
    from .html_parser import HTMLLocatorParser
    PARSER_AVAILABLE = True
except ImportError:
    PARSER_AVAILABLE = False

# ========================================================================
# Helper Functions
# ========================================================================

def html_editor_dialog():
    ws_state = st.session_state.studio_workspace
    page_index = ws_state['editing_html_index']
    page_data = ws_state['html_pages'][page_index]

    @st.dialog(f"Editing HTML for: {page_data['name']}")
    def edit_html():
        st.markdown("Paste your HTML content below.")
        edited_html = st.text_area(
            "HTML Content", height=400,
            value=page_data['html'],
            key=f"dialog_html_content_{page_index}",
            label_visibility="collapsed"
        )
        if st.button("Save and Close", type="primary"):
            ws_state['html_pages'][page_index]['html'] = edited_html
            ws_state['editing_html_index'] = None
            st.rerun()
    edit_html()

def show_checkbox_generator_ui():
    if not st.session_state.get('show_checkbox_generator', False): return
    st.markdown("---")
    st.markdown("#### üìã Checkbox Template Generator")
    
    page_name = st.session_state.get('checkbox_page_name', 'Page')
    detected_pattern = st.session_state.get('checkbox_pattern', '')
    framework = st.session_state.get('checkbox_framework', 'standard')
    description = st.session_state.get('checkbox_description', '')
    
    with st.container(border=True):
        st.info(f"üéØ Detected Framework: **{framework.upper().replace('_', ' ')}**")
        st.caption(f"Pattern: {description}")
        
        page_name = st.text_input("Page Name:", value=page_name, key="checkbox_page_name_input", placeholder="e.g., RoleManagement")
                
        if page_name and detected_pattern:
            st.markdown("---")
            st.markdown("**Suggestion:**")
            try:
                res = generate_checkbox_template_and_keyword(page_name, detected_pattern)
                st.markdown("`*** Variables ***`"); st.code(res['variables'], language="robotframework")
                st.markdown("`*** Keywords ***`"); st.code(res['keywords'], language="robotframework")
            except Exception as e: st.error(f"Error: {e}")
        
            if st.button("‚ùå Close", key="cancel_checkbox_btn", use_container_width=True):
                st.session_state['show_checkbox_generator'] = False
                st.rerun()

def show_checkbox_template_status():
    tpl = st.session_state.get('checkbox_template', {})
    if tpl.get('enabled'):
        with st.container(border=True):
            st.markdown("**üìã Checkbox Template:**")
            c1, c2 = st.columns([3, 1])
            with c1:
                st.caption(f"‚úÖ Page: {tpl['page_name']}")
                st.caption(f"‚úÖ Variable: ${{{tpl['variable']}}}")
                st.caption(f"‚úÖ Keyword: {tpl['keyword']}")
            with c2:
                if st.button("‚ùå Remove", key="remove_checkbox_template"):
                    st.session_state['checkbox_template'] = {'enabled': False}
                    st.rerun()

def generate_file_content_with_checkbox(locators_string):
    checkbox_content = ""
    tpl = st.session_state.get('checkbox_template', {})
    if tpl.get('enabled'):
        try:            
            res = generate_checkbox_template_and_keyword(tpl['page_name'], tpl['xpath'])
            checkbox_content = "\n\n" + res['variables'].replace('*** Variables ***', '') + "\n" + res['keywords'].replace('*** Keywords ***', '')
        except: pass
    
    return textwrap.dedent(f"""
*** Settings ***
Resource            ../resources/commonkeywords.resource

*** Variables ***

# --- START: Generated by Robot Framework Code Generator ---

{locators_string}

# ---  END: Generated by Robot Framework Code Generator  ---
{checkbox_content}
""")

def append_checkbox_template_to_file(file_path):
    tpl = st.session_state.get('checkbox_template', {})
    if not tpl.get('enabled'): return True, ""
    try:        
        res = generate_checkbox_template_and_keyword(tpl['page_name'], tpl['xpath'])
        s1, m1 = append_robot_content_intelligently(file_path, variables_code=res['variables'])
        s2, m2 = append_robot_content_intelligently(file_path, keywords_code=res['keywords'])
        st.session_state['checkbox_template'] = {'enabled': False}
        if s1 and s2: return True, "‚úÖ Locators and checkbox template appended"
        else: return False, f"Error: {m1}, {m2}"
    except Exception as e: return False, str(e)

# ========================================================================
# Main Render Function
# ========================================================================

def render_resources_view_new():
    ws_state = st.session_state.studio_workspace
    if 'editing_html_index' not in ws_state: ws_state['editing_html_index'] = None

    # --- Auto-load locators logic ---
    if not st.session_state.get('locators_auto_loaded') and st.session_state.project_path:
        po_path = os.path.join(st.session_state.project_path, 'pageobjects')
        if os.path.exists(po_path):
            try:
                l_files = []
                for root, _, files in os.walk(po_path):
                    for f in files:
                        if f.endswith(('.robot', '.resource')): l_files.append(os.path.join(root, f))
                if l_files:
                    for fp in l_files:
                        fname = os.path.relpath(fp, st.session_state.project_path)
                        if any(l.get('page_name') == fname for l in ws_state.get('locators', [])): continue
                        try:
                            locs = read_robot_variables_from_content(open(fp, 'r', encoding='utf-8').read())
                            for l in locs: l['page_name'] = fname; l['id'] = str(uuid.uuid4())
                            ws_state.setdefault('locators', []).extend(locs)
                        except: pass
                st.session_state.locators_auto_loaded = True
            except: pass
        else: st.session_state.locators_auto_loaded = True

    # ------------------------------------------------------------------
    # TWO COLUMN LAYOUT (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°)
    # ------------------------------------------------------------------
    panel_grid = st.columns([1, 1], gap="large")

    # --- LEFT: KEYWORDS ---
    with panel_grid[0]:
        st.markdown("#### <i class='fa-solid fa-cubes'></i> üì¶ Common Keywords", unsafe_allow_html=True)
        with st.container(border=True):
            curr_kw = ws_state.get('common_keyword_path', 'N/A')
            st.caption(f"Loaded from: **{curr_kw}**")
            
            uploaded = st.file_uploader("Upload new keywords file to override", type=['robot', 'resource'], key="studio_keyword_uploader_final", label_visibility="collapsed")
            if uploaded and uploaded.name != ws_state.get('common_keyword_path'):
                with st.spinner(f"Parsing {uploaded.name}..."):
                    try:
                        content = uploaded.getvalue().decode("utf-8")
                        ws_state['keywords'] = parse_robot_keywords(content)
                        vars = read_robot_variables_from_content(content)
                        
                        MENU_LOCS = ['homemenu', 'mainmenu', 'submenu', 'menuname']
                        ws_state['menu_locators'] = {v['name']: v for v in vars if v['name'] in MENU_LOCS}
                        ws_state['common_variables'] = [v for v in vars if v['name'] not in MENU_LOCS]
                        ws_state['common_keyword_path'] = uploaded.name
                        st.success(f"Successfully replaced keywords with '{uploaded.name}'!"); st.rerun()
                    except Exception as e: st.error(f"Failed to parse: {e}")

            if ws_state.get('keywords'):
                # CSS for spacing
                st.markdown("""<style>[data-testid="stExpander"] { margin-bottom: 1px !important; }</style>""", unsafe_allow_html=True)
                
                cats = categorize_keywords(ws_state['keywords'])
                stats = get_category_stats(cats)
                exp_conf = get_expansion_config()
                
                c1, c2, c3 = st.columns(3)
                with c1: st.metric("üìä Total Keywords", stats['total_keywords'])
                with c2: st.metric("üìÅ Categories", stats['total_categories'])
                with c3: st.metric("üß© Others", stats['uncategorized'])
                st.markdown("---")

                cat_sort = [k for k in cats.keys() if k != "üß© Others"]
                cat_sort = sorted(cat_sort, key=get_category_priority)
                if "üß© Others" in cats: cat_sort.append("üß© Others")

                mid = (len(cat_sort) + 1) // 2
                col1, col2 = st.columns(2)
                
                with col1:
                    for cat in cat_sort[:mid]:
                        kws = cats.get(cat, [])
                        if not kws: continue
                        with st.expander(f"**{cat}**", expanded=exp_conf.get(cat, False)):
                            for kw in sorted(kws, key=lambda x: x['name']):
                                with st.expander(f"`{kw['name']}`"):
                                    if kw.get('doc'): st.info(f"**Doc:** {kw['doc']}")
                                    args_str = " ".join([f"`{a['name']}`" for a in kw.get('args', [])]) if kw.get('args') else "_None_"
                                    st.markdown(f"**Args:** {args_str}")
                with col2:
                    for cat in cat_sort[mid:]:
                        kws = cats.get(cat, [])
                        if not kws: continue
                        with st.expander(f"**{cat}**", expanded=exp_conf.get(cat, False)):
                            for kw in sorted(kws, key=lambda x: x['name']):
                                with st.expander(f"`{kw['name']}`"):
                                    if kw.get('doc'): st.info(f"**Doc:** {kw['doc']}")
                                    args_str = " ".join([f"`{a['name']}`" for a in kw.get('args', [])]) if kw.get('args') else "_None_"
                                    st.markdown(f"**Args:** {args_str}")

    # --- RIGHT: STATIC LOCATORS (‡∏£‡∏ß‡∏° Add from HTML ‡πÑ‡∏ß‡πâ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà‡∏ï‡∏≤‡∏°‡πÄ‡∏î‡∏¥‡∏°) ---
    with panel_grid[1]:
        st.markdown("#### <i class='fa-solid fa-bullseye'></i> üîç Locators", unsafe_allow_html=True)
        with st.container(border=True):
            with st.expander("üçî Menu Locator Management", expanded=False):
                render_menu_locator_manager()
            
            with st.expander("üìÅ Load from .robot file(s)", expanded=True):
                uploaded_locs = st.file_uploader("Browse files", type=['robot', 'resource'], key="studio_locator_uploader_final_2", accept_multiple_files=True)
                if uploaded_locs:
                    cnt = 0; is_new = False
                    for f in uploaded_locs:
                        if any(l.get('page_name') == f.name for l in ws_state['locators']): continue
                        is_new = True
                        try:
                            content = f.getvalue().decode("utf-8")
                            locs = read_robot_variables_from_content(content)
                            for l in locs: l['page_name'] = f.name; l['id'] = str(uuid.uuid4())
                            ws_state['locators'].extend(locs); cnt += len(locs)
                        except: pass
                    if is_new: st.success(f"Loaded {cnt} new locators."); st.rerun()

            # --- Add from HTML (‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà) ---
            with st.expander("üìÑ Add from HTML", expanded=True):
                for i, page in enumerate(ws_state['html_pages']):
                    c1, c2, c3, c4 = st.columns([1.8, 2.5, 1.2, 0.8])
                    with c1:
                        if 'category_mode' not in page: page['category_mode'] = 'MAINLIST'
                        page['category_mode'] = st.selectbox(f"Cat {i}", ["MAINLIST", "DETAIL", "OTHER"], key=f"cat_select_{i}", index=["MAINLIST", "DETAIL", "OTHER"].index(page.get('category_mode', 'MAINLIST')), label_visibility="collapsed")
                    with c2:
                        ph = "PREFIX (UPPER)" if page['category_mode'] == 'OTHER' else "Page Name"
                        page['name'] = st.text_input(f"Name {i}", page['name'], key=f"studio_html_page_name_{i}", label_visibility="collapsed", placeholder=ph)
                    with c3:
                        if st.button("‚úèÔ∏è Edit", key=f"studio_edit_html_{i}", use_container_width=True): ws_state['editing_html_index'] = i; st.rerun()
                    with c4:
                        if len(ws_state['html_pages']) > 1 and st.button("üóëÔ∏è", key=f"studio_remove_html_page_{i}", width='stretch'): ws_state['html_pages'].pop(i); st.rerun()

                if st.button("‚ûï Add HTML Page", type="secondary", width='stretch'):
                    ws_state['html_pages'].append({'name': f'Page {len(ws_state["html_pages"]) + 1}', 'html': '', 'category_mode': 'MAINLIST'})
                    st.rerun()
                
                st.markdown("---")
                
                if st.button("Find All Locators from HTML", type="primary", width='stretch'):
                    if PARSER_AVAILABLE:
                        parser = HTMLLocatorParser()
                        ws_state['checkbox_locators'] = []
                        pnames = [p['name'] for p in ws_state['html_pages']]
                        ws_state['locators'] = [l for l in ws_state['locators'] if l.get('page_name') not in pnames]
                        
                        new_locs = 0; new_cbs = 0
                        for page in ws_state['html_pages']:
                            if page['html']:
                                prefix = re.sub(r'[^A-Z0-9_]', '_', page['name'].strip().upper()) if page.get('category_mode') == 'OTHER' else page.get('category_mode', '')
                                
                                # Checkbox
                                cb_an = analyze_checkbox_structure(page['html'])
                                soup = BeautifulSoup(page['html'], 'html.parser')
                                if cb_an.get('framework') == 'ant_design':
                                    for div in soup.find_all('div', class_=lambda x: x and 'ant-checkbox-wrapper' in x):
                                        txt = div.get_text(strip=True)
                                        if txt:
                                            var = txt.replace(' ', '_').upper() + '_CHECKBOX'
                                            xp = cb_an['pattern'].replace('::labelcheckbox::', txt)
                                            ws_state.setdefault('checkbox_locators', []).append({'id': str(uuid.uuid4()), 'name': f"LOCATOR_{var}", 'value': xp, 'page_name': page['name'], 'label': txt})
                                            new_cbs += 1
                                if new_cbs > 0: page['html_content_snapshot'] = page['html']; page['checkbox_pattern'] = cb_an

                                # Normal
                                fields = parser.parse_html(page['html'], page_category=prefix)
                                for f in fields:
                                    if '_CHECKBOX' not in f.variable.upper():
                                        name = f"LOCATOR_{f.variable}"
                                        if not any(l['name'] == name for l in ws_state['locators']):
                                            ws_state['locators'].append({'id': str(uuid.uuid4()), 'name': name, 'value': f.xpath, 'page_name': page['name']})
                                            new_locs += 1
                        st.success(f"Found {new_locs} new locators and {new_cbs} new checkboxes."); st.rerun()
                    else: st.error("Parser missing")

    # --- HTML Editor Dialog (Trigger check) ---
    if ws_state.get('editing_html_index') is not None:
        if ws_state['editing_html_index'] < len(ws_state['html_pages']):
            html_editor_dialog()

    # ------------------------------------------------------------------
    # ROW 3: STAGING AREA (FULL WIDTH) - ‡∏≠‡∏¢‡∏π‡πà‡∏•‡πà‡∏≤‡∏á‡∏™‡∏∏‡∏î
    # ------------------------------------------------------------------
    if ws_state.get('locators') or ws_state.get('checkbox_locators'):
        for idx, loc in enumerate(ws_state['locators']):
            if 'id' not in loc: ws_state['locators'][idx]['id'] = str(uuid.uuid4())
            
        st.markdown("<br>", unsafe_allow_html=True)
        with st.expander("#### üìù Locator Staging Area", expanded=True):
            
            # --- Loaded from Files ---
            pnames = [p['name'] for p in ws_state['html_pages']]
            file_locs = [l for l in ws_state['locators'] if l.get('page_name') not in pnames]
            
            if file_locs:
                st.markdown("<h6>üîí From Files (Loaded)</h6>", unsafe_allow_html=True)
                by_file = {}
                for l in file_locs: by_file.setdefault(l['page_name'], []).append(l)
                
                # CSS for Pills
                st.markdown("""<style>.locator-grid-container { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; } .locator-pill { background-color: rgba(88, 166, 255, 0.1); border: 1px solid rgba(88, 166, 255, 0.2); color: #cbd5e1; padding: 5px 10px; border-radius: 12px; font-family: monospace; font-size: 0.8rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; text-align: left; }</style>""", unsafe_allow_html=True)

                for fname, locs in by_file.items():
                    with st.expander(f"üìÑ **{fname}** ({len(locs)} items)", expanded=False):
                        if st.button(f"üóëÔ∏è Unload locators from '{os.path.basename(fname)}'", key=f"unl_{fname}", type="secondary"):
                            ws_state['locators'] = [l for l in ws_state['locators'] if l.get('page_name') != fname]; st.rerun()
                        
                        html_grid = "<div class='locator-grid-container'>"
                        for l in sorted(locs, key=lambda x: x['name']):
                            html_grid += f"<div class='locator-pill' title='{get_clean_locator_name(l['name'])}'>{get_clean_locator_name(l['name'])}</div>"
                        html_grid += "</div>"
                        st.markdown(html_grid, unsafe_allow_html=True)

            # --- From HTML ---
            st.markdown("<h6>‚úèÔ∏è From HTML (Editable)</h6>", unsafe_allow_html=True)
            html_by_page = {}
            for i, loc in enumerate(ws_state['locators']):
                if loc.get('page_name') in pnames:
                    html_by_page.setdefault(loc['page_name'], []).append((i, loc))
            
            cb_by_page = {}
            for c in ws_state.get('checkbox_locators', []):
                if c.get('page_name') in pnames:
                    cb_by_page.setdefault(c['page_name'], []).append(c)

            if not html_by_page and not cb_by_page:
                st.caption("No locators added from HTML yet.")
            else:
                # CSS for Table
                st.markdown("""<style>.locator-header { display: grid; grid-template-columns: 50% 42% 8%; font-weight: 900; padding: 8px 4px; background-color: rgba(88, 166, 255, 0.15); border: 1px solid rgba(88, 166, 255, 0.3); color: #a3c9ff; text-align: center; border-radius: 4px; margin-bottom: 8px; font-size: 0.9rem; } input[key*="loc_name_"], input[key*="loc_value_"] { font-size: 0.7rem !important; font-family: monospace !important; }</style>""", unsafe_allow_html=True)

                for pname in pnames:
                    locs_in_page = html_by_page.get(pname, [])
                    cbs_in_page = cb_by_page.get(pname, [])
                    
                    if not locs_in_page and not cbs_in_page: continue

                    title = f"üìÑ **{pname}** ({len(locs_in_page)} locators" + (f", {len(cbs_in_page)} checkboxes)" if cbs_in_page else ")")
                    with st.expander(title, expanded=True):
                        # Checkbox Button
                        if cbs_in_page:
                            if st.button(f"‚úÖ Found {len(cbs_in_page)} Checkbox(es) - Click to Suggest Handling", key=f"gen_cb_btn_{pname}", type="primary", use_container_width=True):
                                pg = next((p for p in ws_state['html_pages'] if p['name'] == pname), None)
                                if pg:
                                    st.session_state.update({'html_content': pg.get('html_content_snapshot', ''), 'checkbox_page_name': pname, 'checkbox_pattern': pg.get('checkbox_pattern', {}).get('pattern', ''), 'checkbox_framework': pg.get('checkbox_pattern', {}).get('framework', 'standard'), 'show_checkbox_generator': True})
                                    st.rerun()
                            st.markdown("---")
                        
                        # Locators Table
                        if locs_in_page:
                            mid = (len(locs_in_page) + 1) // 2
                            l_list = locs_in_page[:mid]
                            r_list = locs_in_page[mid:]
                            
                            c_l, c_r = st.columns([1, 1], gap="medium")
                            
                            for col, items in [(c_l, l_list), (c_r, r_list)]:
                                with col:
                                    with st.container(border=True):
                                        st.markdown('<div class="locator-header"><div>Name</div><div>Value</div><div>Del</div></div>', unsafe_allow_html=True)
                                        for idx, l_data in items:
                                            l_id = l_data['id']
                                            sc1, sc2, sc3 = st.columns([50, 42, 10])
                                            l_data['name'] = sc1.text_input("N", l_data['name'], key=f"ln_{l_id}", label_visibility="collapsed")
                                            l_data['value'] = sc2.text_input("V", l_data['value'], key=f"lv_{l_id}", label_visibility="collapsed")
                                            if sc3.button("üóëÔ∏è", key=f"ld_{l_id}"):
                                                ws_state['locators'] = [x for x in ws_state['locators'] if x['id'] != l_id]
                                                st.rerun()

            show_checkbox_generator_ui()

            # --- Export Options ---
            st.markdown("---")
            st.subheader("üíæ Export Options")
            if 'locator_save_option' not in st.session_state: st.session_state.locator_save_option = "Append to Existing File"
            
            st.session_state.locator_save_option = st.radio("Save Mode", ["Append to Existing File", "Create New File"], horizontal=True, label_visibility="collapsed")
            save_opt = st.session_state.locator_save_option

            # Prepare string
            html_locs_final = [l for l in ws_state['locators'] if l.get('page_name') in pnames]
            loc_str = ""
            if html_locs_final:
                named = [l for l in html_locs_final if l['name']]
                mx = max(len(f"${{{l['name']}}}") for l in named) + 4 if named else 0
                loc_str = "\n".join([f"{f'${{{l['name']}}}'.ljust(mx)}{l['value']}" for l in named])

            if save_opt == "Append to Existing File":
                files = [f for f in st.session_state.project_structure.get('robot_files', []) if 'pageobjects' in f]
                if files:
                    sel = st.selectbox("Select file:", sorted(files), key="locator_append_target")
                    show_checkbox_template_status()
                    
                    if st.button("‚ûï Append Locators", key="append_locators_btn"):
                        if not html_locs_final and not st.session_state.get('checkbox_template', {}).get('enabled'):
                            st.warning("No data to save.")
                        else:
                            fp = os.path.join(st.session_state.project_path, sel)
                            s1 = True; s2 = True
                            if loc_str: s1, _ = append_robot_content_intelligently(fp, variables_code=loc_str)
                            if st.session_state.get('checkbox_template', {}).get('enabled'): s2, _ = append_checkbox_template_to_file(fp)
                            
                            if s1 and s2:
                                st.session_state['locator_append_success_file'] = sel
                                st.session_state['checkbox_template'] = {'enabled': False}
                    
                    if st.session_state.get('locator_append_success_file') == sel:
                        st.markdown("""<div style='background:#e6fffa;padding:10px;border-radius:5px;border:1px solid #38b2ac;color:#2c7a7b;margin-top:10px;'>‚úÖ Saved! Click Reload to update assets.</div>""", unsafe_allow_html=True)
                        if st.button("üîÑ Reload Assets", key="reload_ui_append", type="primary", use_container_width=True):
                            ws_state['locators'] = [l for l in ws_state['locators'] if l.get('page_name') not in pnames]
                            ws_state['html_pages'] = [{'name': 'Page 1', 'html': '', 'category_mode': 'MAINLIST'}]
                            ws_state['checkbox_locators'] = []
                            st.session_state.locators_auto_loaded = False
                            del st.session_state['locator_append_success_file']
                            st.rerun()
                else: st.warning("No files found in `pageobjects`.")

            elif save_opt == "Create New File":
                fname = st.text_input("New file name:", value="new_locators.robot", key="locator_new_filename")
                show_checkbox_template_status()
                
                if st.button("üìù Create File", key="create_locators_btn"):
                    if not fname.endswith(('.robot', '.resource')): st.error("Invalid extension.")
                    else:
                        content = generate_file_content_with_checkbox(loc_str)
                        path = os.path.join(st.session_state.project_path, "pageobjects", fname)
                        if create_new_robot_file(path, content):
                            st.session_state['show_file_created_success'] = {'path': os.path.relpath(path, st.session_state.project_path)}
                            st.session_state['checkbox_template'] = {'enabled': False}
                            st.session_state.project_structure = scan_robot_project(st.session_state.project_path)

                if st.session_state.get('show_file_created_success'):
                    st.markdown(f"""<div style='background:#e6fffa;padding:10px;border-radius:5px;border:1px solid #38b2ac;color:#2c7a7b;margin-top:10px;'>‚úÖ Created: {st.session_state.show_file_created_success['path']}</div>""", unsafe_allow_html=True)
                    if st.button("üîÑ Reload Assets", key="reload_ui_create", type="primary", use_container_width=True):
                        ws_state['locators'] = [l for l in ws_state['locators'] if l.get('page_name') not in pnames]
                        ws_state['html_pages'] = [{'name': 'Page 1', 'html': '', 'category_mode': 'MAINLIST'}]
                        ws_state['checkbox_locators'] = []
                        st.session_state.locators_auto_loaded = False
                        del st.session_state['show_file_created_success']
                        st.rerun()